#!/bin/sh
#\
exec jimsh "$0" "$@"

array set defs {
  load-reg-> {To From}
  load-lambda-> {To Fn}
  load-const-> {To Const}
  jump {+Off}
  closure-lambda-> {Lambda Nargs}
  closure-reg-> {Reg Nargs}
  closure-fn-> {Fn Nargs}
  closure-tail-lambda-> {Lambda Nargs}
  closure-tail-reg-> {Reg Nargs}
  closure-tail-fn-> {Fn Nargs}
  drop-ret {}
  load-ret-> Reg
  call {}
  tail-call {}
  jump-unless {Reg +Off}
  ret-reg Reg
  ret-lambda Fn
  ret-const Const
  push-error-handler Reg
  pop-error-handler {}
}

set stat_keys {min max 0 1 2 3 <4 <8 <128 <256 >=256}

foreach key $stat_keys {set stat_keys_index($key) -}

proc % {x n} {format %4.2f%% [expr {100.0 * $x / $n}]}

proc sorted_defs {var} {
  upvar 1 $var stat
  global defs
  set list {}
  foreach op [array names defs] {
    lappend list [list $op $stat($op/n)]
  }
  set ret {}
  foreach op [lsort -index 1 -decreasing -integer $list] {
    lappend ret [lindex $op 0]
  }
  return $ret
}

proc show_stat_item {var obj} {
  global stat_keys stat_keys_index
  upvar 1 $var stat
  set name [lindex [split $obj /] end]
  puts "  $name:"
  set avg [expr {1.0 * $stat($obj/sum) / $stat($obj/n)}]
  puts [format "    %5s: %8.2f" avg $avg]
  set keys {}
  foreach key [array names stat $obj/*] {
    set key [lindex [split $key /] end]
    if {$key ne "sum" && ![info exists stat_keys_index($key)]} {
      lappend keys $key
    }
  }
  foreach key [concat $stat_keys $keys] {
    if {[info exists stat($obj/$key)] && $key ni {sum n}} {
      set pc [expr {100.0 * $stat($obj/$key) / $stat($obj/n)}]
      puts [format "    %5s: %5d %8.2f%%"  $key $stat($obj/$key) $pc]
    }
  }
}

proc show_stat {var} {
  global defs
  upvar 1 $var stat
  puts "global"
  puts "  nfuncs: $stat(%func/n)"
  puts "  nclosures: $stat(%closure/n)"
  puts "  ntoplevels: $stat(%toplevel/n)"
  show_stat_item stat nconst
  puts ""
  foreach op [sorted_defs stat] {
    set args $defs($op)
    puts "$op [join $args " "]"
    puts "  n: $stat($op/n) [% $stat($op/n) $stat(n)]"
    set keys {}
    foreach key [array names stat $op/*] {
      set key [lindex [split $key /] 1]
      if {$key ni $args && $key ni {n}} {
        lappend keys $key
      }
    }
    foreach key $keys {
      puts "  $key: $stat($op/$key) [% $stat($op/$key) $stat($op/n)]"
    }
    foreach arg $args {
      show_stat_item stat $op/$arg
    }
    puts ""
  }
}

proc count_item {var key val} {
  upvar 1 $var stat
  incr stat($key/n)
  incr stat($key/sum) $val
  if {![info exists stat($key/max)] || $stat($key/max) < $val} {
    set stat($key/max) $val
  }
  if {![info exists stat($key/min)] || $stat($key/min) > $val} {
    set stat($key/min) $val
  }
  switch -- $val {
    0 - 1 - 2 - 3 {incr stat($key/=$val)}
  } 
  if {$val < 4} {
    incr stat($key/<4)
  } elseif {$val < 8} {
    incr stat($key/<8)
  } elseif {$val < 128} {
    incr stat($key/<128)
  } elseif {$val < 256} {
    incr stat($key/<256)
  } else {
    incr stat($key/>=256)
  }
}

proc init_stat {var} {
  global defs
  upvar 1 $var stat
  foreach op [array names defs] {
    set stat($op/n) 0
    foreach arg $defs($op) {
      set stat($op/$arg/n) 0
      set stat($op/$arg/sum) 0
    }
  }
  foreach x {%func %toplevel %closure} {
    set stat($x/n) 0
  }
}

proc parse {var fd} {
  upvar 1 $var stat
  global defs
  set nconst 0
  set func {}
  while {[gets $fd line] >= 0} {
    switch -regexp -- $line {
      {^[ \t]*$} {}
      {^const .*} {incr nconst}
      {^klvm\.s1\..*} {
        set type [lindex [split [lindex $line 0] .] end]
        incr stat(%$type/n)
        if {$func ne {}} {
          incr stat(nconst/n)
          count_item stat nconst $nconst
        }
        set nconst 0
        set func [lindex $line 1]
      }
      default {
        set args [lassign $line op]
        incr stat(n)
        incr stat($op/n)
        foreach arg $defs($op) val $args {
          if {$arg eq {}} break
          count_item stat $op/$arg $val
        }
        switch -- $op {
          load-reg-> {
            if {[lindex $args 0] > [lindex $args 1]} {
              incr stat($op/arg0>arg1)
            }
          }
        }
      }
    }
  }
  #parray stat
}

proc main {} {
  global argv
  init_stat stat
  if {$argv eq {}} {
    parse stat stdin
  } else {
    foreach file $argv {
      set fd [open $file]
      parse stat $fd
      close $fd
    }
  }
  show_stat stat
}

if {!$tcl_interactive} {
  main
}
