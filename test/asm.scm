(define *asm* (mk-vm))

(define-record-type asm-code
  (mk-asm-code code frame-size nregs)
  asm-code?
  (code asm-code-code)
  (frame-size asm-code-frame-size)
  (nregs asm-code-nregs))

(define (read-asm code vm)
  (define (fn nregs nregs+ body)
    (mk-asm-code (list->vector body) nregs (+ nregs nregs+)))
  (define (mk-func expr)
    (apply (lambda (name args nregs nregs+ body)
             (mk-vm-closure name (length args) (fn nregs nregs+ body) '()))
           (cdr expr)))
  (let loop ((code code)
             (toplevel '()))
    (if (pair? code)
        (let ((expr (car code)))
          (case (car expr)
            ((klvm.s1.func)
             (vm-add-func! (mk-func expr) vm)
             (loop (cdr code) toplevel))
            ((klvm.s1.closure)
             (let ((f (mk-func expr)))
               (table-set! (vm-closures vm) (vm-closure-name f) f)
               (loop (cdr code) toplevel)))
            ((klvm.s1.toplevel)
             (loop (cdr code) (cons (mk-func expr) toplevel))))))))

(define (read-asm-from-file file vm)
  (let ((data (with-input-from-file file read)))
    (read-asm data vm)))

(define (asm-closure-code fn)
  (asm-code-code (vm-closure-code fn)))

(define (asm-closure-frame-size fn)
  (asm-code-frame-size (vm-closure-code fn)))

(define (asm-closure-nregs fn)
  (asm-code-nregs (vm-closure-code fn)))

(define (asm-next-reg fn vm)
  (- (asm-closure-frame-size fn) 1))

(define (asm-nargs-reg fn vm)
  (- (asm-closure-frame-size fn) 2))

(define (asm-prev-sp-reg fn vm)
  (- (asm-closure-frame-size fn) 3))

(define (asm-func-entry fn vm)
  (log/pp `(asm-func-entry: ,fn asm: ,(asm-code? (vm-closure-code fn))))
  (cond ((asm-code? (vm-closure-code fn))
         (let ((nargs (vm-nargs vm))
               (arity (vm-closure-arity fn)))
           (log/pp `(arity: ,arity nargs: ,nargs))
           (cond ((< nargs arity)
                  (vm-wipe vm 0)
                  (set-vm-ret! vm (vm-func-obj (vm-closure-name fn)
                                               arity
                                               (vm-closure-code fn)
                                               vm))
                  #t)
                 ((> nargs arity)
                  (set-vm-sp! vm (+ (vm-sp vm) (- nargs arity)))
                  (set-vm-nargs! vm (- nargs arity))
                  (vm-nregs-> vm (asm-closure-nregs fn))
                  (vm-regs-set! vm (asm-next-reg fn vm) (vm-next vm))
                  (vm-regs-set! vm (asm-nargs-reg fn vm) (vm-nargs vm))
                  (vm-regs-set! vm (asm-prev-sp-reg fn vm) (vm-prev-sp vm))
                  #f)
                 (#t
                  (set-vm-nargs! vm (- nargs arity))
                  (vm-nregs-> vm (asm-closure-nregs fn))
                  (log/pp `(entry sp: ,(vm-sp vm)
                            nargs-reg: ,(asm-nargs-reg fn vm)
                            next-reg: ,(asm-next-reg fn vm)
                            prev-sp-reg: ,(asm-prev-sp-reg fn vm)))
                  (vm-regs-set! vm (asm-next-reg fn vm) (vm-next vm))
                  (vm-regs-set! vm (asm-nargs-reg fn vm) (vm-nargs vm))
                  (vm-regs-set! vm (asm-prev-sp-reg fn vm) (vm-prev-sp vm))
                  #f))))
        ((procedure? (vm-closure-code fn))
         ;; save prev-sp somehow
         ((vm-closure-code fn) #f #f)
         #t)
        (#t (error `(Unknown function object ,fn)))))

(define (asm-run pc vm)
  (define current-fn (car pc))
  (define closure #f)
  (define tmp-reg-nargs #f)

  (define (goto-next next pc)
    (if (pair? pc)
        (next (car pc) (cdr pc))
        (next pc 0)))

  (define (call* next pc)
    (let ((n (+ (vm-nargs vm) (length (vm-closure-vars closure)))))
      (vm-nregs-> vm n)
      (log/pp `(call put args ,(vm-closure-vars closure) nargs: ,(vm-nargs vm)
                sp: ,(vm-sp vm)))
      (vm-put-args (vm-closure-vars closure) (vm-nargs vm) vm)
      (set-vm-nargs! vm n)
      (cond ((procedure? (vm-closure-code closure))
             ((vm-closure-code closure) #f #f)
             (set-vm-sp! vm (vm-prev-sp vm))
             (goto-next next (vm-next vm)))
            ((asm-func-entry closure vm)
             (goto-next next (vm-next vm)))
            (#t
             (set! current-fn closure)
             (next closure 0)
             (set-vm-sp! vm (vm-prev-sp vm))))))

  (define (call next pc)
    (set-vm-next! vm pc)
    (set-vm-prev-sp! vm (vm-sp vm))
    (set-vm-sp! vm (+ (vm-sp vm) (asm-closure-frame-size current-fn)))
    (call* next pc))

  (define (tail-call next pc)
    (set-vm-next! vm (vm-regs-ref vm (asm-next-reg current-fn vm)))
    (set-vm-sp! vm (- (vm-sp vm) tmp-reg-nargs))
    (vm-wipe vm (vm-nargs vm))
    (call* next pc))

  (define (ret x next)
    (log/pp `(ret current-fn: ,current-fn
              sp: ,(vm-sp vm)
              nargs-reg: ,(asm-nargs-reg current-fn vm)
              prev-sp-reg: ,(asm-prev-sp-reg current-fn vm)
              regs: ,(vm-regs vm)))
    (set-vm-nargs! vm (vm-regs-ref vm (asm-nargs-reg current-fn vm)))
    (set-vm-prev-sp! vm (vm-regs-ref vm (asm-prev-sp-reg current-fn vm)))
    (cond ((positive? (vm-nargs vm))
           (set-vm-next! vm (vm-regs-ref vm (asm-next-reg current-fn vm)))
           (set-vm-prev-sp! vm
                            (vm-regs-ref vm (asm-prev-sp-reg current-fn vm)))
           (vm-put-args (vm-closure-vars x) (vm-sp vm) vm)
           (set-vm-sp! vm (- (vm-sp vm) (vm-nargs vm)))
           (set-vm-nargs! vm (+ (vm-nargs vm) (length (vm-closure-vars x))))
           (vm-wipe vm (vm-nargs vm))
           (log/pp `(ret prev-sp: ,(vm-prev-sp vm)))
           (log/pp `(ret x: ,x))
           (cond ((and (vm-closure? x) (procedure? (vm-closure-code x)))
                  ((vm-closure-code x) #f #f)
                  (goto-next next (vm-next vm)))
                 (#t (next x 0))))
          (#t
           (let ((pc (vm-regs-ref vm (asm-next-reg current-fn vm))))
             (set-vm-ret! vm x)
             (set-vm-sp! vm (vm-prev-sp vm))
             (vm-wipe vm 0)
             (goto-next next pc)))))

  (define (ret-reg reg next)
    (ret (vm-regs-ref vm reg) next))

  (define (ret-fn x next)
    (ret (table-ref (vm-closures vm) x) next))

  (define (ret-const x next)
    (ret x next))

  (let loop ((pc0 (car pc))
             (pc1 (cdr pc)))
    (vm-show-step vm (cons pc0 pc1) "STEP")
    (if (and pc0 pc1 (not (vm-end-marker? pc0)))
        (let ((x (vector-ref (asm-closure-code pc0) pc1)))
          (log/pp `(op: ,x))
          (case (car x)
            ((klvm.load-reg->)
             (vm-regs-set! vm (cadr x) (vm-regs-ref vm (caddr x)))
             (loop pc0 (+ pc1 1)))
            ((klvm.load-ret->)
             (vm-regs-set! vm (cadr x) (vm-ret vm))
             (loop pc0 (+ pc1 1)))
            ((klvm.load-fn->)
             (vm-regs-set! vm
                           (cadr x)
                           (table-ref (vm-closures vm) (caddr expr)))
             (loop pc0 (+ pc1 1)))
            ((klvm.load-const->)
             (vm-regs-set! vm (cadr x) (caddr x))
             (loop pc0 (+ pc1 1)))
            ((klvm.closure-reg->)
             (set! closure (vm-regs-ref vm (cadr x)))
             (set-vm-nargs! vm (caddr x))
             (loop pc0 (+ pc1 1)))
            ((klvm.closure-fn->)
             (set! closure (vm-fn-ref vm (cadr x)))
             (set-vm-nargs! vm (caddr x))
             (loop pc0 (+ pc1 1)))
            ((klvm.closure-lambda->)
             (set-vm-nargs! vm (caddr x))
             (set! closure (table-ref (vm-closures vm) (cadr x)))
             (loop pc0 (+ pc1 1)))
            ((klvm.closure-tail-reg->)
             (set! closure (vm-regs-ref vm (cadr x)))
             (set! tmp-reg-nargs
                   (vm-regs-ref vm (asm-nargs-reg current-fn vm)))
             (set-vm-nargs! vm (+ (caddr x) tmp-reg-nargs))
             (loop pc0 (+ pc1 1)))
            ((klvm.closure-tail-fn->)
             (set! closure (vm-fn-ref vm (cadr x)))
             (set! tmp-reg-nargs
                   (vm-regs-ref vm (asm-nargs-reg current-fn vm)))
             (set-vm-nargs! vm (+ (caddr x) tmp-reg-nargs))
             (loop pc0 (+ pc1 1)))
            ((klvm.closure-lambda->)
             (set! tmp-reg-nargs
                   (vm-regs-ref vm (asm-nargs-reg current-fn vm)))
             (set-vm-nargs! vm (+ (caddr x) tmp-reg-nargs))
             (set! closure (table-ref (vm-closures vm) (cadr x)))
             (loop pc0 (+ pc1 1)))
            ((klvm.push-error-handler)
             (vm-push-error-handler (vm-regs-ref vm (cadr expr)) vm)
             (loop pc0 (+ pc1 1)))
            ((klvm.pop-error-handler)
             (vm-pop-error-handler vm)
             (loop pc0 (+ pc1 1)))
            ((klvm.jump) (loop pc0 (+ pc1 1 (cadr x))))
            ((klvm.jmp-unless)
             (loop pc0 (if (vm-regs-ref vm (cadr x))
                           (+ pc1 1)
                           (+ pc1 1 (caddr x)))))
            ((klvm.call) (call loop (cons pc0 (+ pc1 1))))
            ((klvm.void-call) (void-call loop (cons pc0 (+ pc1 1))))
            ((klvm.tail-call) (tail-call loop (cons pc0 (+ pc1 1))))
            ((klvm.ret-reg) (ret-reg (cadr x) loop))
            ((klvm.ret-fn) (ret-fn (cadr x) loop))
            ((klvm.ret-const) (ret-const (cadr x) loop)))))))

(define (asm-call vm fn . args)
  (define (run expr vm)
    (vm-show-step vm #f "asm-call/run")
    (let ((func (vm-ensure-func (car expr) vm)))
      (set-vm-prev-sp! vm (vm-sp vm))
      (cond ((asm-func-entry func vm)
             (vm-wipe vm 0)
             (vm-ret vm))
            (#t
             (vm-show-step vm #f "after entry")
             (asm-run (cons func 0) vm)))))
  (vm-call run vm (cons fn args)))

(define (asm-expr expr)
  (apply asm-call *asm* (car expr) (cdr expr)))
