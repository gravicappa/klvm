(define log-step? #f)
(define *vm* (mk-vm))

(define (number-of-labels labels)
  (let loop ((labels labels)
             (n 0))
    (if (pair? labels)
        (loop (cdr labels) (max n (+ (caar labels) 1)))
        n)))

(define (put-labels-to-vector labels)
  (let ((v (make-vector (number-of-labels labels) '())))
    (let loop ((labels labels))
      (cond ((pair? labels)
             (vector-set! v (caar labels) (cdar labels))
             (loop (cdr labels)))
            (#t v)))))

(define (eval-fn body)
  (let ((vec (put-labels-to-vector body)))
    (lambda (eval-1 idx) (eval-1 (vector-ref vec idx)))))

(define (mk-func code)
  (apply (lambda (name args nregs body)
           (mk-vm-closure name (length args) (eval-fn body) '()))
         (cdr code)))

(define (read-klvm code vm)
  (let loop ((code code)
             (toplevel '()))
    (if (pair? code)
        (let ((x (car code)))
          (case (car x)
            ((klvm.func)
             (vm-add-func! (mk-func x) vm)
             (loop (cdr code) toplevel))
            ((klvm.toplevel) (loop (cdr code) (cons (mk-func x) toplevel)))
            ((klvm.closure)
             (let ((f (mk-func x)))
               (table-set! (vm-closures vm) (vm-closure-name f) f)
               (loop (cdr code) toplevel)))))
        vm)))

(define (read-klvm-from-file file vm)
  (with-input-from-file
   file
   (lambda ()
     (let loop ((obj (read))
                (code '()))
       (if (eof-object? obj)
           (read-klvm (reverse code) vm)
           (loop (read) (cons obj code)))))))

(define (klvm-entry vm func nargs)
  ;; Function entry template returned by (klvm.entry-template)
  (set-vm-sp-top! vm (+ (vm-sp vm) (vm-nargs vm)))
  (log/pp `(entry top: ,(vm-sp-top vm)))
  `((klvm.nargs-cond
     ,nargs
     ((klvm.ret-> (klvm.func-obj ,func ,nargs ,func))
      (klvm.wipe 0)
      (klvm.goto-next))
     ((klvm.nargs- ,nargs))
     ((klvm.sp+ (klvm.nargs))
      (klvm.sp- ,nargs)
      (klvm.nargs- ,nargs)))))

(define (klvm-return x next)
  ;; Function return template returned by (klvm.return-template)
  `((klvm.if-nargs>0
     ((klvm.closure-> ,x)
      (klvm.next-> (klvm.reg ,next))
      (klvm.put-closure-args 0)
      (klvm.wipe 0)
      (klvm.sp- (klvm.nargs))
      (klvm.call))
     ((klvm.ret-> ,x)
      (klvm.next-> (klvm.reg ,next))
      (klvm.wipe 0)
      (klvm.goto-next)))))

(define (func-obj expr func vm)
  (let loop ((i 0)
             (args '()))
    (if (< i (vm-nargs vm))
        (loop (+ i 1)
              (cons (vector-ref (vm-regs vm) (+ (vm-sp vm) i))
                    args))
        (mk-vm-closure (cadr expr)
                       (caddr expr)
                       (vm-closure-code func)
                       (reverse args)))))

(define (put-closure-args offset closure vm)
  (let ((nargs (length (vm-closure-vars closure))))
    (vm-ensure-stack-size! vm (+ (vm-sp vm) nargs offset))
    (let loop ((args (vm-closure-vars closure))
               (i (+ (vm-sp vm) offset)))
      (cond ((pair? args)
             (vector-set! (vm-regs vm) i (car args))
             (loop (cdr args) (+ i 1)))
            (#t (set-vm-nargs! vm (+ (vm-nargs vm) nargs)))))))

(define (klvm-eval func label vm)
  (define closure #f)
  
  (define (eval-2 expr)
    ;(log/pp `(eval-2 ,expr))
    (if (pair? expr)
        (case (car expr)
          ((klvm.reg) (vector-ref (vm-regs vm) (+ (vm-sp vm) (cadr expr))))
          ((klvm.ret) (vm-ret vm))
          ((klvm.next) (vm-next vm))
          ((klvm.nargs) (vm-nargs vm))
          ((klvm.func-obj) (func-obj expr func vm))
          ((klvm.lambda) (table-ref (vm-closures vm) (cadr expr)))
          (else (error `(unexpected expr2 ,expr))))
        (case expr
          ((true) #t)
          ((false) #f)
          (else expr))))
  
  (define (eval-1 exprs)
    (if (pair? exprs)
        (let ((expr (car exprs)))
          (log/pp `(eval-1 ,expr))
          (case (car expr)
            ((klvm.entry)
             (eval-1 (append (klvm-entry vm (cadr expr) (caddr expr))
                             (cdr exprs))))
            ((klvm.return)
             (eval-1 (append (klvm-return (cadr expr) (caddr expr))
                             (cdr expr))))
            ((klvm.goto) (cons func (cadr expr)))
            ((klvm.call) (cons closure 0))
            ((klvm.goto-next) (vm-next vm))
            ((klvm.if)
             (if (eval-2 (cadr expr))
                 (eval-1 (cons (caddr expr) (cdr exprs)))
                 (eval-1 (cons (cadddr expr) (cdr exprs)))))
            ((klvm.nargs-cond)
             (log/pp `(nargs-cond
                       nargs: ,(vm-nargs vm)
                       arity: ,(cadr expr)
                       func: ,(vm-closure-name func)))
             (cond ((< (vm-nargs vm) (cadr expr))
                    (eval-1 (append (list-ref expr 2) (cdr exprs))))
                   ((= (vm-nargs vm) (cadr expr))
                    (eval-1 (append (list-ref expr 3) (cdr exprs))))
                   ((> (vm-nargs vm) (cadr expr))
                    (eval-1 (append (list-ref expr 4) (cdr exprs))))))
            ((klvm.if-nargs>0)
             (if (> (vm-nargs vm) 0)
                 (eval-1 (append (cadr expr) (cdr exprs)))
                 (eval-1 (append (caddr expr) (cdr exprs)))))
            ((klvm.closure->)
             (with-exception-catcher
               (lambda (e) e)
               (lambda ()
                 (set! closure (vm-ensure-func (eval-2 (cadr expr)) vm))
                 (eval-1 (cdr exprs)))))
            (else
             (case (car expr)
               ((klvm.push-error-handler)
                (vm-push-error-handler (eval-2 (cadr expr)) vm))
               ((klvm.pop-error-handler) (vm-pop-error-handler vm))
               ((klvm.put-closure-args)
                (put-closure-args (cadr expr) closure vm))
               ((klvm.ret->) (set-vm-ret! vm (eval-2 (cadr expr))))
               ((klvm.nregs->) (vm-nregs-> vm (eval-2 (cadr expr))))
               ((klvm.reg->)
                (vector-set! (vm-regs vm)
                             (+ (vm-sp vm) (cadr expr))
                             (eval-2 (caddr expr))))
               ((klvm.next->)
                (set-vm-next! vm (if (number? (cadr expr))
                                     (cons func (cadr expr))
                                     (eval-2 (cadr expr)))))
               ((klvm.sp+)
                (set-vm-sp! vm (+ (vm-sp vm) (eval-2 (cadr expr)))))
               ((klvm.sp-)
                (set-vm-sp! vm (- (vm-sp vm) (eval-2 (cadr expr)))))
               ((klvm.nargs->) (set-vm-nargs! vm (eval-2 (cadr expr))))
               ((klvm.nargs+)
                (set-vm-nargs! vm (+ (vm-nargs vm) (eval-2 (cadr expr)))))
               ((klvm.nargs-)
                (set-vm-nargs! vm (- (vm-nargs vm) (eval-2 (cadr expr)))))
               ((klvm.wipe) (vm-wipe vm (eval-2 (cadr expr))))
               (else (error `(unexpected ,expr))))
             (eval-1 (cdr exprs)))))
        #f))

  ((vm-closure-code func) eval-1 label))

(define (show-step vm pc title)
  (define (str-pc pc)
    (if (and (pair? pc)
             (vm-closure? (car pc))
             (vm-closure-name (car pc)))
        (cons (vm-closure-name (car pc)) (cdr pc))
        pc))
  (cond (log-step?
         (log/puts "")
         (log/puts (mkstr "## " title))
         (log/pp `(cur: ,(str-pc pc)))
         (log/pp `(nargs: ,(vm-nargs vm)))
         (log/pp `(sp: ,(vm-sp vm)))
         (log/pp `(sp-top: ,(vm-sp-top vm)))
         (log/pp `(ret: ,(vm-ret vm)))
         (log/pp `(next: ,(str-pc (vm-next vm))))
         (log/pp `(regs: ,(if #t
                              (vm-regs vm)
                              (subvector (vm-regs vm)
                                         (vm-sp vm)
                                         (vector-length (vm-regs vm)))))))))

(define (klvm-run func label vm)
  (let loop ((next (cons func label)))
    (show-step vm next "STEP")
    (cond ((pair? next) (loop (klvm-eval (car next) (cdr next) vm)))
          ((not next) #t)
          ((vm-end-marker? next) #t)
          (#t
           (log/pp `(exception: ,next))
           (log/pp `(handlers: ,(vm-err-handlers vm)))
           (log/pp `(sp: ,(vm-sp vm)))
           (log/pp `(sp-top: ,(vm-sp-top vm)))
           (let ((e (vm-pop-error-handler vm)))
             (cond ((vm-error-handler? e)
                    (log/pp `(handler: ,e))
                    (set-vm-sp! vm (vm-error-handler-sp e))
                    (set-vm-next! vm (vm-error-handler-next e))
                    (vm-wipe vm 0)
                    (klvm-call* (vm-error-handler-func e) (list next) vm)
                    (loop (cons (vm-error-handler-func e) 0)))
                   (#t (error `(unhandled exception ,next)))))))))

(define (klvm-call vm fn . args)
  (define (run expr vm)
    (klvm-run (vm-ensure-func (car expr) vm) 0 vm))
  (vm-call run vm (cons fn args)))

(define (klvm-expr expr)
  (apply klvm-call *vm* (car expr) (cdr expr)))
