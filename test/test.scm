(define *test-results* '())
(define (reset-tests!) (set! *test-results* '()))
(define abort-test-on-error? #f)

(define-record-type test-result
  (mk-test-result i expr result)
  test-result?
  (i test-result-i)
  (expr test-result-expr)
  (result test-result-result))

(define (mkstr . args)
  (with-output-to-string '()
    (lambda () (for-each display args))))

(define (fold f start lst)
  (if (pair? lst)
      (fold f (f (car lst) start) (cdr lst))
      start))

(define (show-test-result r)
  (let ((result (if (eq? (test-result-result r) #t)
                    "OK"
                    (mkstr "ERROR: " (test-result-result r))))
        (expr (test-result-expr r))
        (i (test-result-i r)))
    (display (mkstr i ": " (car expr) " => " (cdr expr)  " : " result))
    (newline)))

(define (add-test-result! i expr result)
  (let ((obj (mk-test-result i expr result)))
    (show-test-result obj)
    (set! *test-results* (cons obj *test-results*))
    (eq? result #t)))

(define (run-test i fn expr expected)
  (define (strerr e)
    (with-output-to-string '() (lambda () (display-exception e))))
  (with-exception-catcher
    (lambda (e) (add-test-result! i (cons expr expected) (strerr e)))
    (lambda ()
      (let* ((ret (fn expr))
             (result (if (equal? ret expected)
                         #t
                         (mkstr "ERROR: " ret " != " expected))))
        (add-test-result! i (cons expr ret) result)))))

(define (run-test-exprs fn defs)
  (let ((n (/ (length defs) 3)))
    (let loop ((defs defs)
               (i 0))
      (cond ((not (pair? defs)))
            ((run-test i fn (car defs) (caddr defs))
             (loop (cdddr defs) (+ i 1)))
            ((not abort-test-on-error?) (loop (cdddr defs) (+ i 1)))))))

(define (show-test-results-summary total results)
  (let loop ((results (reverse results))
             (nok 0)
             (errs '()))
    (cond ((pair? results)
           (let ((res (car results)))
             (if (eq? (test-result-result res) #t)
                 (loop (cdr results) (+ nok 1) errs)
                 (loop (cdr results) nok (cons (test-result-i res) errs)))))
          (#t
           (newline)
           (display (mkstr "# DONE " total " tests"))
           (newline)
           (cond ((pair? errs)
                  (display (mkstr (length errs) " errors:"))
                  (for-each (lambda (e) (display (mkstr " " e)))
                            (reverse errs))))
           (newline)))))

(define (show-test-results results total)
  (newline)
  (display "TEST RESULTS")
  (newline)
  (display "============")
  (newline)
  (for-each show-test-result (reverse results))
  (show-test-results-summary total results))

(define (test fn defs)
  (reset-tests!)
  (run-test-exprs fn defs)
  (show-test-results *test-results* (/ (length defs) 3)))

(define (test-ref defs i)
  (list-ref defs (* i 3)))
